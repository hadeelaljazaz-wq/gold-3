Gold Nightmare Pro - Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø°ÙƒÙŠ Ù„Ù„Ø°Ù‡Ø¨

> **Ù†Ø¸Ø§Ù… Ù…ØªÙ‚Ø¯Ù… ÙŠØ¬Ù…Ø¹ AI/ML + Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ + Ø§Ù„Ø£Ø®Ø¨Ø§Ø± + Backtesting**

---

## ğŸ“Š Ø§Ù„Ù‡Ø¯Ù: Ø±ÙØ¹ Ø¯Ù‚Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ù† 70% Ø¥Ù„Ù‰ 85%+

---

## ğŸ§  Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø£ÙˆÙ„: Ù†Ø¸Ø§Ù… AI/ML Ø§Ù„Ù…ØªÙ‚Ø¯Ù…

### 1ï¸âƒ£ Ù†Ù…ÙˆØ°Ø¬ LSTM Ù„Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø£Ø³Ø¹Ø§Ø±

import 'package:tflite_flutter/tflite_flutter.dart';
import 'dart:math';

class LSTMPricePredictor {
  static final LSTMPricePredictor _instance = LSTMPricePredictor._internal();
  
  late Interpreter _interpreter;
  final List<PredictionResult> _historyPredictions = [];
  
  static const int sequenceLength = 60;
  static const int features = 10;
  static const int predictionSteps = 24;
  
  LSTMPricePredictor._internal();
  
  factory LSTMPricePredictor() => _instance;

  Future<void> initialize() async {
    try {
      _interpreter = await Interpreter.fromAsset('models/lstm_gold_model.tflite');
      AppLogger().info('âœ… LSTM Model loaded successfully');
    } catch (e) {
      AppLogger().error('âŒ Failed to load LSTM model: $e');
      rethrow;
    }
  }

  Future<AdvancedPredictionResult> predictPrice({
    required List<CandleData> historicalData,
    required MarketContext context,
  }) async {
    try {
      if (historicalData.length < sequenceLength) {
        throw Exception('ÙŠØ¬Ø¨ ØªÙˆÙØ± ${sequenceLength} Ø´Ù…Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
      }

      final inputData = _prepareInputData(historicalData, context);
      final rawPredictions = _runModel(inputData);
      final predictions = _postProcessPredictions(rawPredictions, historicalData);
      
      final confidence = _calculateAdvancedConfidence(
        historicalData,
        predictions,
        context,
      );
      
      final levels = _identifySupportResistance(historicalData, predictions);
      final trendAnalysis = _analyzeTrend(predictions, context);
      
      final recommendations = _generateRecommendations(
        predictions,
        confidence,
        levels,
        trendAnalysis,
        context,
      );
      
      final result = AdvancedPredictionResult(
        predictions: predictions,
        confidence: confidence,
        supportLevels: levels.support,
        resistanceLevels: levels.resistance,
        trend: trendAnalysis,
        recommendations: recommendations,
        marketContext: context,
        timestamp: DateTime.now(),
        modelVersion: '2.0-LSTM',
      );
      
      _historyPredictions.add(result);
      return result;
    } catch (e) {
      AppLogger().error('âŒ Prediction error: $e');
      rethrow;
    }
  }

  List<List<List<double>>> _prepareInputData(
    List<CandleData> data,
    MarketContext context,
  ) {
    final input = <List<List<double>>>[];
    final recentData = data.sublist(max(0, data.length - sequenceLength));
    
    final normalizedPrices = _normalizeData(
      recentData.map((c) => c.close).toList(),
    );
    
    for (int i = 0; i < recentData.length; i++) {
      final features = [
        normalizedPrices[i],
        _calculateRSI(recentData, i) / 100.0,
        _calculateMACD(recentData, i) / 50.0,
        _calculateBollingerPosition(recentData, i),
        _calculateADX(recentData, i) / 100.0,
        _calculateStochastic(recentData, i) / 100.0,
        _calculateATR(recentData, i) / 100.0,
        context.economicSentiment,
        context.volatilityIndex / 100.0,
        recentData[i].volume / 1000000,
      ];
      
      input.add([features]);
    }
    
    return input;
  }

  List<double> _runModel(List<List<List<double>>> input) {
    final output = List.filled(predictionSteps, 0.0).reshape([1, predictionSteps]);
    _interpreter.run(input, output);
    return output[0];
  }

  ConfidenceMetrics _calculateAdvancedConfidence(
    List<CandleData> historical,
    List<PricePoint> predictions,
    MarketContext context,
  ) {
    final modelAccuracy = _calculateHistoricalAccuracy();
    final marketStability = _calculateMarketStability(historical);
    final dataQuality = _assessDataQuality(historical);
    final indicatorConsensus = _checkIndicatorConsensus(historical);
    final newsImpact = context.newsImpactScore;
    
    final overallConfidence = (
      modelAccuracy * 0.30 +
      marketStability * 0.25 +
      dataQuality * 0.20 +
      indicatorConsensus * 0.15 +
      (1.0 - newsImpact) * 0.10
    );
    
    return ConfidenceMetrics(
      overall: _capConfidence(overallConfidence),
      modelAccuracy: modelAccuracy,
      marketStability: marketStability,
      dataQuality: dataQuality,
      indicatorConsensus: indicatorConsensus,
      newsImpact: newsImpact,
    );
  }

  double _calculateHistoricalAccuracy() {
    if (_historyPredictions.isEmpty) return 0.65;
    
    int correctPredictions = 0;
    int totalPredictions = 0;
    
    for (final prediction in _historyPredictions) {
      if (prediction.actualOutcome != null) {
        totalPredictions++;
        
        final predictedDirection = prediction.predictions.first.price > 
                                   prediction.predictions.last.price;
        final actualDirection = prediction.actualOutcome!.direction;
        
        if (predictedDirection == actualDirection) {
          correctPredictions++;
        }
      }
    }
    
    if (totalPredictions == 0) return 0.65;
    return correctPredictions / totalPredictions;
  }

  double _calculateMarketStability(List<CandleData> data) {
    if (data.length < 20) return 0.5;
    
    final recentData = data.sublist(data.length - 20);
    final prices = recentData.map((c) => c.close).toList();
    
    final mean = prices.reduce((a, b) => a + b) / prices.length;
    final variance = prices
        .map((p) => pow(p - mean, 2))
        .reduce((a, b) => a + b) / prices.length;
    final stdDev = sqrt(variance);
    
    final coefficientOfVariation = stdDev / mean;
    return max(0.0, min(1.0, 1.0 - (coefficientOfVariation * 10)));
  }

  double _assessDataQuality(List<CandleData> data) {
    double quality = 1.0;
    
    int gaps = 0;
    for (int i = 1; i < data.length; i++) {
      final timeDiff = data[i].timestamp.difference(data[i - 1].timestamp);
      if (timeDiff.inHours > 2) gaps++;
    }
    quality -= (gaps / data.length) * 0.3;
    
    final prices = data.map((c) => c.close).toList();
    final mean = prices.reduce((a, b) => a + b) / prices.length;
    final stdDev = sqrt(
      prices.map((p) => pow(p - mean, 2)).reduce((a, b) => a + b) / prices.length
    );
    
    int outliers = 0;
    for (final price in prices) {
      if ((price - mean).abs() > 3 * stdDev) outliers++;
    }
    quality -= (outliers / data.length) * 0.2;
    
    return max(0.0, min(1.0, quality));
  }

  double _checkIndicatorConsensus(List<CandleData> data) {
    if (data.length < 50) return 0.5;
    
    final rsi = _calculateRSI(data, data.length - 1);
    final macd = _calculateMACD(data, data.length - 1);
    final stochastic = _calculateStochastic(data, data.length - 1);
    final adx = _calculateADX(data, data.length - 1);
    
    int bullishSignals = 0;
    int bearishSignals = 0;
    
    if (rsi > 50) bullishSignals++ else bearishSignals++;
    if (macd > 0) bullishSignals++ else bearishSignals++;
    if (stochastic > 50) bullishSignals++ else bearishSignals++;
    
    final trendStrength = adx / 100.0;
    final maxSignals = max(bullishSignals, bearishSignals);
    final totalSignals = bullishSignals + bearishSignals;
    final consensus = maxSignals / totalSignals;
    
    return consensus * trendStrength;
  }

  SupportResistanceLevels _identifySupportResistance(
    List<CandleData> historical,
    List<PricePoint> predictions,
  ) {
    final allPrices = [
      ...historical.map((c) => c.close),
      ...predictions.map((p) => p.price),
    ];
    
    final pivotPoints = _calculatePivotPoints(historical);
    final psychologicalLevels = _findPsychologicalLevels(allPrices);
    final historicalLevels = _findHistoricalLevels(historical);
    
    final support = <PriceLevel>[
      ...pivotPoints.support,
      ...psychologicalLevels.support,
      ...historicalLevels.support,
    ]..sort((a, b) => b.price.compareTo(a.price));
    
    final resistance = <PriceLevel>[
      ...pivotPoints.resistance,
      ...psychologicalLevels.resistance,
      ...historicalLevels.resistance,
    ]..sort((a, b) => a.price.compareTo(b.price));
    
    return SupportResistanceLevels(
      support: _deduplicateLevels(support),
      resistance: _deduplicateLevels(resistance),
    );
  }

  PivotPointLevels _calculatePivotPoints(List<CandleData> data) {
    final lastCandle = data.last;
    
    final pivot = (lastCandle.high + lastCandle.low + lastCandle.close) / 3;
    
    final r1 = (2 * pivot) - lastCandle.low;
    final r2 = pivot + (lastCandle.high - lastCandle.low);
    final r3 = lastCandle.high + 2 * (pivot - lastCandle.low);
    
    final s1 = (2 * pivot) - lastCandle.high;
    final s2 = pivot - (lastCandle.high - lastCandle.low);
    final s3 = lastCandle.low - 2 * (lastCandle.high - pivot);
    
    return PivotPointLevels(
      pivot: PriceLevel(pivot, 'Pivot', 0.9),
      support: [
        PriceLevel(s1, 'S1', 0.85),
        PriceLevel(s2, 'S2', 0.75),
        PriceLevel(s3, 'S3', 0.65),
      ],
      resistance: [
        PriceLevel(r1, 'R1', 0.85),
        PriceLevel(r2, 'R2', 0.75),
        PriceLevel(r3, 'R3', 0.65),
      ],
    );
  }

  List<PriceLevel> _deduplicateLevels(List<PriceLevel> levels) {
    if (levels.isEmpty) return [];
    
    final deduplicated = <PriceLevel>[];
    
    for (final level in levels) {
      bool isDuplicate = false;
      
      for (final existing in deduplicated) {
        if ((level.price - existing.price).abs() < existing.price * 0.005) {
          isDuplicate = true;
          if (level.strength > existing.strength) {
            deduplicated.remove(existing);
            deduplicated.add(level);
          }
          break;
        }
      }
      
      if (!isDuplicate) {
        deduplicated.add(level);
      }
    }
    
    return deduplicated.take(5).toList();
  }

  TrendAnalysis _analyzeTrend(
    List<PricePoint> predictions,
    MarketContext context,
  ) {
    final firstPrice = predictions.first.price;
    final lastPrice = predictions.last.price;
    final change = ((lastPrice - firstPrice) / firstPrice) * 100;
    
    TrendType type;
    if (change > 1.5) {
      type = TrendType.strongBullish;
    } else if (change > 0.5) {
      type = TrendType.bullish;
    } else if (change < -1.5) {
      type = TrendType.strongBearish;
    } else if (change < -0.5) {
      type = TrendType.bearish;
    } else {
      type = TrendType.sideways;
    }
    
    final strength = min(1.0, change.abs() / 5.0);
    final entryPoints = _findEntryPoints(predictions, type);
    final exitPoints = _findExitPoints(predictions, type);
    
    return TrendAnalysis(
      type: type,
      strength: strength,
      change: change,
      entryPoints: entryPoints,
      exitPoints: exitPoints,
      duration: predictions.length,
    );
  }

  List<TradingRecommendation> _generateRecommendations(
    List<PricePoint> predictions,
    ConfidenceMetrics confidence,
    SupportResistanceLevels levels,
    TrendAnalysis trend,
    MarketContext context,
  ) {
    final recommendations = <TradingRecommendation>[];
    
    if (trend.type == TrendType.strongBullish && confidence.overall > 0.7) {
      recommendations.add(TradingRecommendation(
        action: TradeAction.strongBuy,
        confidence: confidence.overall,
        entryPrice: predictions.first.price,
        targetPrice: predictions.last.price,
        stopLoss: levels.support.isNotEmpty ? levels.support.first.price : predictions.first.price * 0.98,
        timeframe: '24 Ø³Ø§Ø¹Ø©',
        reason: 'Ø§ØªØ¬Ø§Ù‡ ØµØ¹ÙˆØ¯ÙŠ Ù‚ÙˆÙŠ Ù…Ø¹ Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© (${(confidence.overall * 100).toStringAsFixed(1)}%)',
        riskRewardRatio: _calculateRiskReward(
          predictions.first.price,
          predictions.last.price,
          levels.support.isNotEmpty ? levels.support.first.price : predictions.first.price * 0.98,
        ),
      ));
    }
    
    recommendations.sort((a, b) => b.confidence.compareTo(a.confidence));
    return recommendations.take(3).toList();
  }

  double _calculateRiskReward(double entry, double target, double stopLoss) {
    final potentialProfit = (target - entry).abs();
    final potentialLoss = (entry - stopLoss).abs();
    
    if (potentialLoss == 0) return 0.0;
    return potentialProfit / potentialLoss;
  }

  double _capConfidence(double confidence) {
    return min(0.85, max(0.35, confidence));
  }

  // Helper Methods
  List<double> _normalizeData(List<double> data) {
    if (data.isEmpty) return [];
    final mean = data.reduce((a, b) => a + b) / data.length;
    final variance = data.map((x) => pow(x - mean, 2)).reduce((a, b) => a + b) / data.length;
    final stdDev = sqrt(variance);
    if (stdDev == 0) return data.map((_) => 0.0).toList();
    return data.map((x) => (x - mean) / stdDev).toList();
  }

  double _calculateRSI(List<CandleData> data, int index) {
    if (index < 14) return 50.0;
    double gains = 0, losses = 0;
    for (int i = index - 14; i < index; i++) {
      final change = data[i + 1].close - data[i].close;
      if (change > 0) gains += change;
      else losses += change.abs();
    }
    final avgGain = gains / 14;
    final avgLoss = losses / 14;
    if (avgLoss == 0) return 100.0;
    final rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }

  double _calculateMACD(List<CandleData> data, int index) {
    if (index < 26) return 0.0;
    final ema12 = _calculateEMA(data, index, 12);
    final ema26 = _calculateEMA(data, index, 26);
    return ema12 - ema26;
  }

  double _calculateEMA(List<CandleData> data, int index, int period) {
    if (index < period) return data[index].close;
    final multiplier = 2.0 / (period + 1);
    var ema = data[index - period].close;
    for (int i = index - period + 1; i <= index; i++) {
      ema = (data[i].close * multiplier) + (ema * (1 - multiplier));
    }
    return ema;
  }

  double _calculateBollingerPosition(List<CandleData> data, int index) {
    if (index < 20) return 0.5;
    final recentPrices = data.sublist(index - 20, index + 1).map((c) => c.close).toList();
    final sma = recentPrices.reduce((a, b) => a + b) / recentPrices.length;
    final variance = recentPrices.map((p) => pow(p - sma, 2)).reduce((a, b) => a + b) / recentPrices.length;
    final stdDev = sqrt(variance);
    final upperBand = sma + (stdDev * 2);
    final lowerBand = sma - (stdDev * 2);
    final currentPrice = data[index].close;
    if (upperBand == lowerBand) return 0.5;
    return (currentPrice - lowerBand) / (upperBand - lowerBand);
  }

  double _calculateADX(List<CandleData> data, int index) {
    if (index < 14) return 25.0;
    return 50.0;
  }

  double _calculateStochastic(List<CandleData> data, int index) {
    if (index < 14) return 50.0;
    final period = data.sublist(index - 14, index + 1);
    final highest = period.map((c) => c.high).reduce(max);
    final lowest = period.map((c) => c.low).reduce(min);
    final current = data[index].close;
    if (highest == lowest) return 50.0;
    return ((current - lowest) / (highest - lowest)) * 100;
  }

  double _calculateATR(List<CandleData> data, int index) {
    if (index < 14) return 50.0;
    double sum = 0;
    for (int i = index - 14; i < index; i++) {
      final tr = max(
        data[i].high - data[i].low,
        max(
          (data[i].high - data[i - 1].close).abs(),
          (data[i].low - data[i - 1].close).abs(),
        ),
      );
      sum += tr;
    }
    return sum / 14;
  }

  PsychologicalLevels _findPsychologicalLevels(List<double> prices) {
    final currentPrice = prices.last;
    final support = <PriceLevel>[];
    final resistance = <PriceLevel>[];
    
    for (int i = -5; i <= 5; i++) {
      if (i == 0) continue;
      final roundNumber = (currentPrice / 10).round() * 10 + (i * 10);
      if (roundNumber < currentPrice) {
        support.add(PriceLevel(roundNumber.toDouble(), 'Ù†ÙØ³ÙŠ: $roundNumber', 0.7));
      } else if (roundNumber > currentPrice) {
        resistance.add(PriceLevel(roundNumber.toDouble(), 'Ù†ÙØ³ÙŠ: $roundNumber', 0.7));
      }
    }
    return PsychologicalLevels(support: support, resistance: resistance);
  }

  HistoricalLevels _findHistoricalLevels(List<CandleData> data) {
    final support = <PriceLevel>[];
    final resistance = <PriceLevel>[];
    
    for (int i = 2; i < data.length - 2; i++) {
      final candle = data[i];
      if (candle.low < data[i - 1].low && candle.low < data[i - 2].low &&
          candle.low < data[i + 1].low && candle.low < data[i + 2].low) {
        final touchCount = _countTouches(data, candle.low, isSupport: true);
        final strength = min(1.0, touchCount / 5.0);
        support.add(PriceLevel(candle.low, 'Ø¯Ø¹Ù… ØªØ§Ø±ÙŠØ®ÙŠ', strength));
      }
      if (candle.high > data[i - 1].high && candle.high > data[i - 2].high &&
          candle.high > data[i + 1].high && candle.high > data[i + 2].high) {
        final touchCount = _countTouches(data, candle.high, isSupport: false);
        final strength = min(1.0, touchCount / 5.0);
        resistance.add(PriceLevel(candle.high, 'Ù…Ù‚Ø§ÙˆÙ…Ø© ØªØ§Ø±ÙŠØ®ÙŠØ©', strength));
      }
    }
    
    return HistoricalLevels(support: support, resistance: resistance);
  }

  int _countTouches(List<CandleData> data, double level, {required bool isSupport}) {
    int count = 0;
    final tolerance = level * 0.002;
    for (final candle in data) {
      final priceToCheck = isSupport ? candle.low : candle.high;
      if ((priceToCheck - level).abs() <= tolerance) count++;
    }
    return count;
  }

  List<EntryPoint> _findEntryPoints(List<PricePoint> predictions, TrendType trend) {
    final entryPoints = <EntryPoint>[];
    for (int i = 1; i < predictions.length - 1; i++) {
      final current = predictions[i];
      final prev = predictions[i - 1];
      final next = predictions[i + 1];
      
      if (trend == TrendType.bullish || trend == TrendType.strongBullish) {
        if (current.price < prev.price && current.price < next.price) {
          entryPoints.add(EntryPoint(
            timestamp: current.timestamp,
            price: current.price,
            type: EntryType.buy,
            reason: 'Pullback ÙÙŠ Ø§ØªØ¬Ø§Ù‡ ØµØ¹ÙˆØ¯ÙŠ',
            confidence: 0.75,
          ));
        }
      }
    }
    return entryPoints;
  }

  List<ExitPoint> _findExitPoints(List<PricePoint> predictions, TrendType trend) {
    final exitPoints = <ExitPoint>[];
    final atr = 50.0;
    
    if (predictions.isNotEmpty) {
      final entry = predictions.first;
      
      if (trend == TrendType.bullish || trend == TrendType.strongBullish) {
        exitPoints.add(ExitPoint(
          timestamp: entry.timestamp.add(const Duration(hours: 12)),
          price: entry.price + atr,
          type: ExitType.takeProfit,
          reason: 'Ù‡Ø¯Ù Ø±Ø¨Ø­ 1 (1 ATR)',
          confidence: 0.8,
        ));
        exitPoints.add(ExitPoint(
          timestamp: entry.timestamp,
          price: entry.price - atr,
          type: ExitType.stopLoss,
          reason: 'ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© (1 ATR)',
          confidence: 0.9,
        ));
      }
    }
    return exitPoints;
  }
}

---

## ğŸ“° Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø«Ø§Ù†ÙŠ: Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø®Ø¨Ø§Ø± Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ

### 2ï¸âƒ£ ØªØ­Ù„ÙŠÙ„ Ù…Ø¹Ù†ÙˆÙŠØ§Øª Ø§Ù„Ø£Ø®Ø¨Ø§Ø± (Sentiment Analysis)

// pubspec.yaml
dependencies:
  textbullet: ^1.1.0  # NLP
  firebase_ml_vision: ^0.12.0  # ML Kit

// lib/services/news/sentiment_analyzer.dart

import 'package:textbullet/textbullet.dart';

class NewsSentimentAnalyzer {
  static final NewsSentimentAnalyzer _instance = NewsSentimentAnalyzer._internal();
  
  late TextBullet _textBullet;
  final Map<String, NewsSentiment> _sentimentCache = {};
  
  NewsSentimentAnalyzer._internal();
  
  factory NewsSentimentAnalyzer() => _instance;

  Future<void> initialize() async {
    try {
      _textBullet = TextBullet();
      AppLogger().info('âœ… Sentiment Analyzer initialized');
    } catch (e) {
      AppLogger().error('âŒ Sentiment analyzer init failed: $e');
    }
  }

  /// ØªØ­Ù„ÙŠÙ„ Ù…Ø¹Ù†ÙˆÙŠØ§Øª Ø§Ù„Ù†Øµ
  Future<NewsSentiment> analyzeSentiment(String text) async {
    try {
      if (_sentimentCache.containsKey(text)) {
        return _sentimentCache[text]!;
      }

      final sentiment = _textBullet.getScores(text);
      
      final score = (sentiment['positive'] ?? 0.0) - (sentiment['negative'] ?? 0.0);
      final magnitude = (sentiment['positive'] ?? 0.0) + (sentiment['negative'] ?? 0.0);
      
      final result = NewsSentiment(
        score: score, // -1 Ø¥Ù„Ù‰ +1
        magnitude: magnitude, // Ù‚ÙˆØ© Ø§Ù„Ø¹Ø§Ø·ÙØ©
        isPositive: score > 0.1,
        isNegative: score < -0.1,
        isNeutral: score.abs() <= 0.1,
        emotions: _extractEmotions(sentiment),
      );
      
      _sentimentCache[text] = result;
      return result;
    } catch (e) {
      AppLogger().error('âŒ Sentiment analysis failed: $e');
      return NewsSentiment.neutral();
    }
  }

  Map<String, double> _extractEmotions(Map<String, dynamic> sentiment) {
    return {
      'joy': sentiment['joy'] ?? 0.0,
      'anger': sentiment['anger'] ?? 0.0,
      'fear': sentiment['fear'] ?? 0.0,
      'sadness': sentiment['sadness'] ?? 0.0,
      'surprise': sentiment['surprise'] ?? 0.0,
      'confidence': sentiment['confidence'] ?? 0.0,
    };
  }
}

class NewsSentiment {
  final double score; // -1 to +1
  final double magnitude; // 0 to 1
  final bool isPositive;
  final bool isNegative;
  final bool isNeutral;
  final Map<String, double> emotions;

  NewsSentiment({
    required this.score,
    required this.magnitude,
    required this.isPositive,
    required this.isNegative,
    required this.isNeutral,
    required this.emotions,
  });

  factory NewsSentiment.neutral() => NewsSentiment(
    score: 0.0,
    magnitude: 0.0,
    isPositive: false,
    isNegative: false,
    isNeutral: true,
    emotions: {},
  );
}

### 3ï¸âƒ£ Ø®Ø¯Ù…Ø© Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø®Ø¨Ø§Ø± Ù…Ù† APIs

// lib/services/news/news_service.dart

class NewsService {
  static final NewsService _instance = NewsService._internal();
  
  final dio = Dio();
  static const String _newsApiKey = 'YOUR_NEWS_API_KEY';
  static const String _marketDataApiKey = 'YOUR_MARKET_DATA_KEY';
  
  late StreamController<List<GoldNews>> _newsStreamController;
  
  NewsService._internal();
  
  factory NewsService() => _instance;

  void initialize() {
    _newsStreamController = StreamController<List<GoldNews>>.broadcast();
    _startNewsUpdates();
  }

  /// Ø¬Ù„Ø¨ Ø£Ø®Ø¨Ø§Ø± Ø§Ù„Ø°Ù‡Ø¨
  Future<List<GoldNews>> fetchGoldNews({
    int limit = 20,
    Duration recency = const Duration(hours: 24),
  }) async {
    try {
      final now = DateTime.now();
      final yesterday = now.subtract(recency);
      
      // Ø¬Ù„Ø¨ Ù…Ù† NewsAPI
      final response = await dio.get(
        'https://newsapi.org/v2/everything',
        queryParameters: {
          'q': 'gold OR XAU/USD OR "spot gold" OR "gold prices"',
          'apiKey': _newsApiKey,
          'sortBy': 'publishedAt',
          'language': 'en',
          'from': yesterday.toIso8601String(),
          'pageSize': limit,
        },
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to fetch news: ${response.statusCode}');
      }

      final articles = (response.data['articles'] as List)
          .map((a) => GoldNews.fromJson(a))
          .toList();

      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¹Ù†ÙˆÙŠØ§Øª Ù„ÙƒÙ„ Ø®Ø¨Ø±
      for (final article in articles) {
        final titleSentiment = await NewsSentimentAnalyzer().analyzeSentiment(article.title);
        final descriptionSentiment = article.description != null
            ? await NewsSentimentAnalyzer().analyzeSentiment(article.description!)
            : NewsSentiment.neutral();

        article.sentiment = NewsSentiment(
          score: (titleSentiment.score * 0.7 + descriptionSentiment.score * 0.3),
          magnitude: max(titleSentiment.magnitude, descriptionSentiment.magnitude),
          isPositive: titleSentiment.score > 0 || descriptionSentiment.score > 0,
          isNegative: titleSentiment.score < 0 || descriptionSentiment.score < 0,
          isNeutral: titleSentiment.isNeutral && descriptionSentiment.isNeutral,
          emotions: {...titleSentiment.emotions, ...descriptionSentiment.emotions},
        );

        // ÙƒØ´Ù Ø§Ù„Ø£Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ù‡Ù…Ø©
        article.importance = _assessNewsImportance(article);
      }

      return articles;
    } catch (e) {
      AppLogger().error('âŒ Failed to fetch gold news: $e');
      return [];
    }
  }

  /// ØªÙ‚ÙŠÙŠÙ… Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø®Ø¨Ø±
  NewsImportance _assessNewsImportance(GoldNews article) {
    double importance = 0.0;

    // Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª Ù…Ù‡Ù…Ø©
    final keywords = ['crash', 'surge', 'rally', 'collapse', 'record', 'spike', 'plunge', 'soar'];
    if (keywords.any((k) => article.title.toLowerCase().contains(k))) {
      importance += 0.3;
    }

    // Ù…Ø¹Ù†ÙˆÙŠØ§Øª Ù‚ÙˆÙŠØ©
    if (article.sentiment!.magnitude > 0.7) {
      importance += 0.3;
    }

    // Ù…Ù† Ù…ØµØ¯Ø± Ù…ÙˆØ«ÙˆÙ‚
    final trustedSources = ['bloomberg', 'reuters', 'cnbc', 'marketwatch', 'investing.com'];
    if (trustedSources.any((s) => article.source.toLowerCase().contains(s))) {
      importance += 0.2;
    }

    // ØªØ§Ø±ÙŠØ® Ø­Ø¯ÙŠØ« Ø¬Ø¯Ø§Ù‹
    final age = DateTime.now().difference(article.publishedAt);
    if (age.inHours < 2) {
      importance += 0.2;
    }

    if (importance > 0.75) return NewsImportance.critical;
    if (importance > 0.5) return NewsImportance.high;
    if (importance > 0.25) return NewsImportance.medium;
    return NewsImportance.low;
  }

  /// Ø¨Ø« Ø§Ù„Ø£Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
  Stream<List<GoldNews>> get newsStream => _newsStreamController.stream;

  void _startNewsUpdates() {
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø®Ø¨Ø§Ø± ÙƒÙ„ 30 Ø¯Ù‚ÙŠÙ‚Ø©
    Timer.periodic(Duration(minutes: 30), (_) async {
      final news = await fetchGoldNews();
      _newsStreamController.add(news);
    });
  }

  Future<MarketImpactScore> calculateImpactScore(List<GoldNews> news) async {
    if (news.isEmpty) {
      return MarketImpactScore(
        score: 0.0,
        direction: NewsDirection.neutral,
        confidence: 0.0,
        recentNews: 0,
      );
    }

    // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙˆÙ‚
    double totalSentiment = 0.0;
    int weightedCount = 0;

    for (final article in news) {
      final weight = _getArticleWeight(article.importance!);
      totalSentiment += article.sentiment!.score * weight;
      weightedCount += weight;
    }

    final averageSentiment = weightedCount > 0 ? totalSentiment / weightedCount : 0.0;

    return MarketImpactScore(
      score: averageSentiment.abs(),
      direction: averageSentiment > 0.1 
          ? NewsDirection.bullish
          : averageSentiment < -0.1 
              ? NewsDirection.bearish
              : NewsDirection.neutral,
      confidence: min(1.0, news.length / 10.0), // Ø«Ù‚Ø© Ø£Ø¹Ù„Ù‰ Ù…Ø¹ Ø£Ø®Ø¨Ø§Ø± Ø£ÙƒØ«Ø±
      recentNews: news.length,
    );
  }

  int _getArticleWeight(NewsImportance importance) {
    switch (importance) {
      case NewsImportance.critical:
        return 5;
      case NewsImportance.high:
        return 3;
      case NewsImportance.medium:
        return 2;
      case NewsImportance.low:
        return 1;
    }
  }

  void dispose() {
    _newsStreamController.close();
  }
}

class GoldNews {
  final String title;
  final String? description;
  final String url;
  final String source;
  final DateTime publishedAt;
  final String? imageUrl;
  
  late NewsSentiment? sentiment;
  late NewsImportance? importance;

  GoldNews({
    required this.title,
    this.description,
    required this.url,
    required this.source,
    required this.publishedAt,
    this.imageUrl,
  });

  factory GoldNews.fromJson(Map<String, dynamic> json) {
    return GoldNews(
      title: json['title'] ?? '',
      description: json['description'],
      url: json['url'] ?? '',
      source: json['source']?['name'] ?? 'Unknown',
      publishedAt: DateTime.tryParse(json['publishedAt'] ?? '') ?? DateTime.now(),
      imageUrl: json['urlToImage'],
    );
  }
}

enum NewsImportance { critical, high, medium, low }
enum NewsDirection { bullish, bearish, neutral }

class MarketImpactScore {
  final double score; // 0 to 1
  final NewsDirection direction;
  final double confidence;
  final int recentNews;

  MarketImpactScore({
    required this.score,
    required this.direction,
    required this.confidence,
    required this.recentNews,
  });
}

---

## ğŸ§ª Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø«Ø§Ù„Ø«: Ù†Ø¸Ø§Ù… Backtesting Ø§Ù„Ù…ØªÙ‚Ø¯Ù…

### 4ï¸âƒ£ Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ¯Ø§ÙˆÙ„

// lib/services/backtesting/backtester.dart

class BacktestingEngine {
  static final BacktestingEngine _instance = BacktestingEngine._internal();
  
  BacktestingEngine._internal();
  
  factory BacktestingEngine() => _instance;

  /// ØªØ´ØºÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ©
  Future<BacktestResult> runBacktest({
    required List<CandleData> historicalData,
    required TradingStrategy strategy,
    required double initialBalance,
    required double riskPerTrade,
  }) async {
    try {
      final trades = <ExecutedTrade>[];
      var currentBalance = initialBalance;
      var equity = initialBalance;
      var drawdown = 0.0;
      var maxDrawdown = 0.0;
      var openTrade = null;
      
      final equityHistory = <EquityPoint>[
        EquityPoint(
          timestamp: historicalData.first.timestamp,
          equity: equity,
          balance: currentBalance,
        ),
      ];

      for (int i = 0; i < historicalData.length - 1; i++) {
        final candle = historicalData[i];
        final nextCandle = historicalData[i + 1];
        
        // Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
        final signal = strategy.generateSignal(historicalData, i);
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
        if (signal != TradeSignal.none && openTrade == null) {
          // ÙØªØ­ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
          final riskAmount = currentBalance * riskPerTrade;
          
          openTrade = OpenTrade(
            entryPrice: nextCandle.open,
            entryTime: nextCandle.timestamp,
            quantity: riskAmount / nextCandle.open,
            signal: signal,
            stopLoss: signal == TradeSignal.buy 
                ? nextCandle.open * 0.98 
                : nextCandle.open * 1.02,
            takeProfit: signal == TradeSignal.buy 
                ? nextCandle.open * 1.03 
                : nextCandle.open * 0.97,
          );
          
          AppLogger().debug('ğŸ“ˆ Buy signal at ${nextCandle.open}');
        }
        
        // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…ÙØªÙˆØ­Ø©
        if (openTrade != null) {
          final currentPrice = candle.high;
          
          // ÙØ­Øµ Stop Loss
          if (openTrade.signal == TradeSignal.buy && currentPrice <= openTrade.stopLoss) {
            final trade = ExecutedTrade(
              entryPrice: openTrade.entryPrice,
              exitPrice: openTrade.stopLoss,
              quantity: openTrade.quantity,
              entryTime: openTrade.entryTime,
              exitTime: candle.timestamp,
              profitLoss: (openTrade.stopLoss - openTrade.entryPrice) * openTrade.quantity,
              reason: 'Stop Loss',
            );
            
            trades.add(trade);
            currentBalance += trade.profitLoss;
            openTrade = null;
            AppLogger().debug('ğŸ›‘ Stop Loss hit: ${trade.profitLoss}');
          }
          
          // ÙØ­Øµ Take Profit
          if (openTrade != null && 
              openTrade.signal == TradeSignal.buy && 
              currentPrice >= openTrade.takeProfit) {
            
            final trade = ExecutedTrade(
              entryPrice: openTrade.entryPrice,
              exitPrice: openTrade.takeProfit,
              quantity: openTrade.quantity,
              entryTime: openTrade.entryTime,
              exitTime: candle.timestamp,
              profitLoss: (openTrade.takeProfit - openTrade.entryPrice) * openTrade.quantity,
              reason: 'Take Profit',
            );
            
            trades.add(trade);
            currentBalance += trade.profitLoss;
            openTrade = null;
            AppLogger().debug('âœ… Take Profit hit: ${trade.profitLoss}');
          }
        }
        
        // ØªØ­Ø¯ÙŠØ« Equity
        equity = currentBalance;
        if (openTrade != null) {
          final unrealizedPL = (candle.close - openTrade.entryPrice) * openTrade.quantity;
          equity = currentBalance + unrealizedPL;
        }
        
        // ØªØªØ¨Ø¹ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ØªØ±Ø§Ø¬Ø¹
        final ddValue = ((equity - currentBalance) / currentBalance);
        drawdown = ddValue;
        if (drawdown.abs() > maxDrawdown.abs()) {
          maxDrawdown = drawdown;
        }
        
        equityHistory.add(EquityPoint(
          timestamp: candle.timestamp,
          equity: equity,
          balance: currentBalance,
        ));
      }
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³
      final result = _calculateBacktestMetrics(
        trades: trades,
        equityHistory: equityHistory,
        initialBalance: initialBalance,
        maxDrawdown: maxDrawdown,
      );
      
      return result;
    } catch (e) {
      AppLogger().error('âŒ Backtesting error: $e');
      rethrow;
    }
  }

  BacktestResult _calculateBacktestMetrics({
    required List<ExecutedTrade> trades,
    required List<EquityPoint> equityHistory,
    required double initialBalance,
    required double maxDrawdown,
  }) {
    if (trades.isEmpty) {
      return BacktestResult(
        totalTrades: 0,
        winningTrades: 0,
        losingTrades: 0,
        winRate: 0.0,
        totalProfit: 0.0,
        profitFactor: 0.0,
        sharpeRatio: 0.0,
        maxDrawdown: 0.0,
        roi: 0.0,
        equityHistory: equityHistory,
      );
    }

    // Ø¹Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ø±Ø§Ø¨Ø­Ø© ÙˆØ§Ù„Ø®Ø§Ø³Ø±Ø©
    final winningTrades = trades.where((t) => t.profitLoss > 0).toList();
    final losingTrades = trades.where((t) => t.profitLoss < 0).toList();

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
    final totalProfit = trades.fold<double>(0, (sum, t) => sum + t.profitLoss);
    final grossProfit = winningTrades.fold<double>(0, (sum, t) => sum + t.profitLoss);
    final grossLoss = losingTrades.fold<double>(0, (sum, t) => sum + t.profitLoss.abs());

    // Ù†Ø³Ø¨Ø© Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±
    final profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 0.0;

    // Ø­Ø³Ø§Ø¨ Sharpe Ratio
    final returns = <double>[];
    for (int i = 1; i < equityHistory.length; i++) {
      final dailyReturn = (equityHistory[i].equity - equityHistory[i - 1].equity) /
          equityHistory[i - 1].equity;
      returns.add(dailyReturn);
    }

    double sharpeRatio = 0.0;
    if (returns.isNotEmpty) {
      final mean = returns.reduce((a, b) => a + b) / returns.length;
      final variance = returns
          .map((r) => pow(r - mean, 2))
          .reduce((a, b) => a + b) / returns.length;
      final stdDev = sqrt(variance);
      
      if (stdDev > 0) {
        sharpeRatio = (mean * sqrt(252)) / stdDev; // 252 Ø£ÙŠØ§Ù… ØªØ¯Ø§ÙˆÙ„
      }
    }

    // Ø§Ù„Ø¹Ø§Ø¦Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±
    final finalEquity = equityHistory.last.equity;
    final roi = ((finalEquity - initialBalance) / initialBalance) * 100;

    return BacktestResult(
      totalTrades: trades.length,
      winningTrades: winningTrades.length,
      losingTrades: losingTrades.length,
      winRate: (winningTrades.length / trades.length) * 100,
      totalProfit: totalProfit,
      profitFactor: profitFactor,
      sharpeRatio: sharpeRatio,
      maxDrawdown: maxDrawdown * 100,
      roi: roi,
      equityHistory: equityHistory,
      trades: trades,
    );
  }
}

abstract class TradingStrategy {
  TradeSignal generateSignal(List<CandleData> data, int currentIndex);
}

enum TradeSignal { buy, sell, none }

class ExecutedTrade {
  final double entryPrice;
  final double exitPrice;
  final double quantity;
  final DateTime entryTime;
  final DateTime exitTime;
  final double profitLoss;
  final String reason;

  ExecutedTrade({
    required this.entryPrice,
    required this.exitPrice,
    required this.quantity,
    required this.entryTime,
    required this.exitTime,
    required this.profitLoss,
    required this.reason,
  });
}

class OpenTrade {
  final double entryPrice;
  final DateTime entryTime;
  final double quantity;
  final TradeSignal signal;
  final double stopLoss;
  final double takeProfit;

  OpenTrade({
    required this.entryPrice,
    required this.entryTime,
    required this.quantity,
    required this.signal,
    required this.stopLoss,
    required this.takeProfit,
  });
}

class EquityPoint {
  final DateTime timestamp;
  final double equity;
  final double balance;

  EquityPoint({
    required this.timestamp,
    required this.equity,
    required this.balance,
  });
}

class BacktestResult {
  final int totalTrades;
  final int winningTrades;
  final int losingTrades;
  final double winRate;
  final double totalProfit;
  final double profitFactor;
  final double sharpeRatio;
  final double maxDrawdown;
  final double roi;
  final List<EquityPoint> equityHistory;
  final List<ExecutedTrade>? trades;

  BacktestResult({
    required this.totalTrades,
    required this.winningTrades,
    required this.losingTrades,
    required this.winRate,
    required this.totalProfit,
    required this.profitFactor,
    required this.sharpeRatio,
    required this.maxDrawdown,
    required this.roi,
    required this.equityHistory,
    this.trades,
  });
}

---

## ğŸ”” Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø±Ø§Ø¨Ø¹: Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ©

### 5ï¸âƒ£ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©

// lib/services/alerts/alert_manager.dart

class SmartAlertManager {
  static final SmartAlertManager _instance = SmartAlertManager._internal();
  
  final List<PriceAlert> _alerts = [];
  final _alertController = StreamController<Alert>.broadcast();
  
  SmartAlertManager._internal();
  
  factory SmartAlertManager() => _instance;

  Stream<Alert> get alertStream => _alertController.stream;

  /// Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¨ÙŠÙ‡ Ø³Ø¹Ø±
  void addPriceAlert({
    required double price,
    required AlertType type,
    required String label,
  }) {
    _alerts.add(PriceAlert(
      price: price,
      type: type,
      label: label,
      createdAt: DateTime.now(),
    ));
    
    AppLogger().info('â• Price alert added: $label at $price');
  }

  /// ÙØ­Øµ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª
  void checkAlerts(double currentPrice) {
    for (final alert in _alerts) {
      bool triggered = false;
      
      switch (alert.type) {
        case AlertType.priceAbove:
          triggered = currentPrice >= alert.price;
          break;
        case AlertType.priceBelow:
          triggered = currentPrice <= alert.price;
          break;
        case AlertType.priceBreakAbove:
          triggered = currentPrice > alert.price;
          break;
        case AlertType.priceBreakBelow:
          triggered = currentPrice < alert.price;
          break;
      }
      
      if (triggered && !alert.triggered) {
        alert.triggered = true;
        
        final alertEvent = Alert(
          title: alert.label,
          message: 'Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: \$${currentPrice.toStringAsFixed(2)}',
          type: alert.type,
          timestamp: DateTime.now(),
          priority: AlertPriority.high,
        );
        
        _alertController.add(alertEvent);
        _sendNotification(alertEvent);
        AppLogger().warning('ğŸ”” Alert triggered: ${alert.label}');
      }
    }
  }

  void _sendNotification(Alert alert) {
    // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Firebase Cloud Messaging Ø£Ùˆ local_notifications
    AppLogger().info('ğŸ“¢ Notification: ${alert.title} - ${alert.message}');
  }

  void removeAlert(PriceAlert alert) {
    _alerts.remove(alert);
    AppLogger().info('âŒ Alert removed: ${alert.label}');
  }

  void dispose() {
    _alertController.close();
  }
}

enum AlertType { priceAbove, priceBelow, priceBreakAbove, priceBreakBelow }
enum AlertPriority { low, medium, high, critical }

class PriceAlert {
  final double price;
  final AlertType type;
  final String label;
  final DateTime createdAt;
  bool triggered = false;

  PriceAlert({
    required this.price,
    required this.type,
    required this.label,
    required this.createdAt,
  });
}

class Alert {
  final String title;
  final String message;
  final AlertType type;
  final DateTime timestamp;
  final AlertPriority priority;

  Alert({
    required this.title,
    required this.message,
    required this.type,
    required this.timestamp,
    required this.priority,
  });
}

---

## ğŸ“Š Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø®Ø§Ù…Ø³: Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠØ©

### 6ï¸âƒ£ Ø¨Ù†Ø§Ø¡ Dashboard Ù…ØªÙ‚Ø¯Ù…

// pubspec.yaml
dependencies:
  fl_chart: ^0.68.0
  syncfusion_flutter_charts: ^24.1.47

// lib/ui/dashboard/gold_dashboard.dart

import 'package:fl_chart/fl_chart.dart';

class GoldAnalyticsDashboard extends StatefulWidget {
  @override
  State<GoldAnalyticsDashboard> createState() => _GoldAnalyticsDashboardState();
}

class _GoldAnalyticsDashboardState extends State<GoldAnalyticsDashboard> {
  late AdvancedPredictionResult prediction;
  late List<GoldNews> news;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  void _loadData() async {
    // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    final historicalData = await _getHistoricalData();
    final context = await _getMarketContext();
    
    prediction = await LSTMPricePredictor().predictPrice(
      historicalData: historicalData,
      context: context,
    );
    
    news = await NewsService().fetchGoldNews();
    
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('ğŸ“Š Gold Nightmare Pro - ØªØ­Ù„ÙŠÙ„Ø§Øª'),
        backgroundColor: Color(0xFF1F2937),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1. Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø«Ù‚Ø©
            _buildConfidenceCard(prediction.confidence),
            SizedBox(height: 16),
            
            // 2. Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ù„Ù„ØªÙ†Ø¨Ø¤
            _buildPredictionChart(prediction.predictions),
            SizedBox(height: 16),
            
            // 3. Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©
            _buildSupportResistanceCard(
              prediction.supportLevels,
              prediction.resistanceLevels,
            ),
            SizedBox(height: 16),
            
            // 4. Ø§Ù„ØªÙˆØµÙŠØ§Øª
            _buildRecommendationsCard(prediction.recommendations),
            SizedBox(height: 16),
            
            // 5. Ø¢Ø®Ø± Ø§Ù„Ø£Ø®Ø¨Ø§Ø±
            _buildNewsWidget(news),
            SizedBox(height: 16),
            
            // 6. Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ø£Ø¯Ø§Ø¡
            _buildPerformanceMetrics(prediction.confidence),
          ],
        ),
      ),
    );
  }

  Widget _buildConfidenceCard(ConfidenceMetrics confidence) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('ğŸ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                CircleAvatar(
                  radius: 40,
                  backgroundColor: _getConfidenceColor(confidence.overall),
                  child: Text(
                    '${(confidence.overall * 100).toStringAsFixed(0)}%',
                    style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                ),
              ],
            ),
            SizedBox(height: 16),
            
            // ØªÙØµÙŠÙ„ Ø§Ù„Ø«Ù‚Ø©
            _buildConfidenceBar('Ø¯Ù‚Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬', confidence.modelAccuracy),
            _buildConfidenceBar('Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ø³ÙˆÙ‚', confidence.marketStability),
            _buildConfidenceBar('Ø¬ÙˆØ¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', confidence.dataQuality),
            _buildConfidenceBar('ØªÙˆØ§ÙÙ‚ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª', confidence.indicatorConsensus),
          ],
        ),
      ),
    );
  }

  Widget _buildConfidenceBar(String label, double value) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(label, style: TextStyle(fontSize: 12)),
              Text('${(value * 100).toStringAsFixed(0)}%', style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold)),
            ],
          ),
          SizedBox(height: 4),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: value,
              minHeight: 8,
              backgroundColor: Colors.grey[300],
              valueColor: AlwaysStoppedAnimation(_getConfidenceColor(value)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPredictionChart(List<PricePoint> predictions) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ğŸ“ˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø£Ø³Ø¹Ø§Ø± (24 Ø³Ø§Ø¹Ø©)', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(show: true),
                  titlesData: FlTitlesData(
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(showTitles: true, reservedSize: 40),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        getTitlesWidget: (value, meta) {
                          return Text('${value.toInt()}h', style: TextStyle(fontSize: 10));
                        },
                      ),
                    ),
                  ),
                  lineBarsData: [
                    LineChartBarData(
                      spots: predictions
                          .asMap()
                          .entries
                          .map((e) => FlSpot(e.key.toDouble(), e.value.price))
                          .toList(),
                      isCurved: true,
                      color: Color(0xFFD97706),
                      barWidth: 3,
                      dotData: FlDotData(show: true),
                      belowBarData: BarAreaData(
                        show: true,
                        color: Color(0xFFD97706).withOpacity(0.3),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSupportResistanceCard(
    List<PriceLevel> support,
    List<PriceLevel> resistance,
  ) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ğŸ¯ Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            SizedBox(height: 16),
            
            // Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©
            Text('Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© ğŸ”´', style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: Colors.red)),
            ...resistance.map((level) => _buildLevelTile(level, isResistance: true)),
            
            SizedBox(height: 16),
            
            // Ø§Ù„Ø¯Ø¹Ù…
            Text('Ø§Ù„Ø¯Ø¹Ù… ğŸŸ¢', style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: Colors.green)),
            ...support.map((level) => _buildLevelTile(level, isResistance: false)),
          ],
        ),
      ),
    );
  }

  Widget _buildLevelTile(PriceLevel level, {required bool isResistance}) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(level.label, style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500)),
              Text('\$${level.price.toStringAsFixed(2)}', style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold)),
            ],
          ),
          Chip(
            label: Text('${(level.strength * 100).toStringAsFixed(0)}%'),
            backgroundColor: isResistance ? Colors.red[100] : Colors.green[100],
            labelStyle: TextStyle(fontSize: 11),
          ),
        ],
      ),
    );
  }

  Widget _buildRecommendationsCard(List<TradingRecommendation> recommendations) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ğŸ’¡ Ø§Ù„ØªÙˆØµÙŠØ§Øª', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            SizedBox(height: 16),
            ...recommendations.map((rec) => _buildRecommendationTile(rec)),
          ],
        ),
      ),
    );
  }

  Widget _buildRecommendationTile(TradingRecommendation rec) {
    final actionColor = _getActionColor(rec.action);
    
    return Container(
      margin: EdgeInsets.only(bottom: 12),
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: actionColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: actionColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(rec.actionText, style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: actionColor)),
              Chip(
                label: Text('${(rec.confidence * 100).toStringAsFixed(0)}%'),
                backgroundColor: actionColor.withOpacity(0.3),
                labelStyle: TextStyle(fontSize: 11),
              ),
            ],
          ),
          SizedBox(height: 8),
          _buildRecDetails('Ø§Ù„Ø¯Ø®ÙˆÙ„', '\$${rec.entryPrice.toStringAsFixed(2)}'),
          _buildRecDetails('Ø§Ù„Ù‡Ø¯Ù', '\$${rec.targetPrice.toStringAsFixed(2)}'),
          _buildRecDetails('Ø§Ù„Ø®Ø³Ø§Ø±Ø©', '\$${rec.stopLoss.toStringAsFixed(2)}'),
          _buildRecDetails('Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©:Ø§Ù„Ø¹Ø§Ø¦Ø¯', '1:${rec.riskRewardRatio.toStringAsFixed(2)}'),
          SizedBox(height: 8),
          Text(rec.reason, style: TextStyle(fontSize: 11, fontStyle: FontStyle.italic, color: Colors.grey[700])),
        ],
      ),
    );
  }

  Widget _buildRecDetails(String label, String value) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: TextStyle(fontSize: 11, color: Colors.grey[600])),
          Text(value, style: TextStyle(fontSize: 11, fontWeight: FontWeight.w500)),
        ],
      ),
    );
  }

  Widget _buildNewsWidget(List<GoldNews> news) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ğŸ“° Ø¢Ø®Ø± Ø§Ù„Ø£Ø®Ø¨Ø§Ø±', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            SizedBox(height: 12),
            ...news.take(5).map((article) => _buildNewsItem(article)),
          ],
        ),
      ),
    );
  }

  Widget _buildNewsItem(GoldNews article) {
    final sentimentColor = article.sentiment!.isPositive
        ? Colors.green
        : article.sentiment!.isNegative
            ? Colors.red
            : Colors.grey;
    
    return Padding(
      padding: EdgeInsets.only(bottom: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      article.title,
                      style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    SizedBox(height: 4),
                    Text(
                      article.source,
                      style: TextStyle(fontSize: 10, color: Colors.grey[600]),
                    ),
                  ],
                ),
              ),
              SizedBox(width: 8),
              Container(
                padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: sentimentColor.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  '${(article.sentiment!.score * 100).toStringAsFixed(0)}%',
                  style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: sentimentColor),
                ),
              ),
            ],
          ),
          Divider(height: 12),
        ],
      ),
    );
  }

  Widget _buildPerformanceMetrics(ConfidenceMetrics confidence) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ğŸ“Š Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ø£Ø¯Ø§Ø¡', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildMetricBox('Ø§Ù„Ø¯Ù‚Ø©', '${(confidence.modelAccuracy * 100).toStringAsFixed(0)}%'),
                _buildMetricBox('Ø§Ù„Ø«Ø¨Ø§Øª', '${(confidence.marketStability * 100).toStringAsFixed(0)}%'),
                _buildMetricBox('Ø§Ù„ØªÙˆØ§ÙÙ‚', '${(confidence.indicatorConsensus * 100).toStringAsFixed(0)}%'),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMetricBox(String label, String value) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Color(0xFFD97706))),
        SizedBox(height: 4),
        Text(label, style: TextStyle(fontSize: 12, color: Colors.grey[600])),
      ],
    );
  }

  Color _getConfidenceColor(double confidence) {
    if (confidence > 0.8) return Colors.green;
    if (confidence > 0.6) return Colors.orange;
    return Colors.red;
  }

  Color _getActionColor(TradeAction action) {
    switch (action) {
      case TradeAction.strongBuy:
      case TradeAction.buy:
        return Colors.green;
      case TradeAction.strongSell:
      case TradeAction.sell:
        return Colors.red;
      case TradeAction.hold:
        return Colors.orange;
    }
  }

  Future<List<CandleData>> _getHistoricalData() async {
    // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
    return [];
  }

  Future<MarketContext> _getMarketContext() async {
    return MarketContext(
      economicSentiment: 0.5,
      volatilityIndex: 15.0,
      newsImpactScore: 0.3,
      upcomingEvents: [],
    );
  }
}

---

## ğŸ”— Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø³Ø§Ø¯Ø³: ØªÙƒØ§Ù…Ù„ APIs Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©

### 7ï¸âƒ£ Ø§Ù„Ø®ÙˆØ§Ø¯Ù… ÙˆØ§Ù„ØªÙƒØ§Ù…Ù„Ø§Øª

// lib/services/api/gold_market_api.dart

class GoldMarketApiService {
  static final GoldMarketApiService _instance = GoldMarketApiService._internal();
  
  final dio = Dio();
  
  GoldMarketApiService._internal();
  
  factory GoldMarketApiService() => _instance;

  /// Ø¬Ù„Ø¨ Ø³Ø¹Ø± Ø§Ù„Ø°Ù‡Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ù† Ø®ÙˆØ§Ø¯Ù… Ù…ÙˆØ«ÙˆÙ‚Ø©
  Future<GoldPrice> getCurrentGoldPrice() async {
    try {
      // Ø§Ø³ØªØ®Ø¯Ù… APIs Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„Ø¯Ù‚Ø©
      final responses = await Future.wait([
        _fetchFromMetals(),
        _fetchFromAlphaVantage(),
        _fetchFromIEX(),
      ]);

      // Ø§Ø­Ø³Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…ÙˆØ²ÙˆÙ†
      final avgPrice = _calculateWeightedAverage(responses);
      
      return GoldPrice(
        price: avgPrice,
        timestamp: DateTime.now(),
        sources: responses.length,
      );
    } catch (e) {
      AppLogger().error('âŒ Failed to fetch gold price: $e');
      rethrow;
    }
  }

  Future<double> _fetchFromMetals() async {
    final response = await dio.get(
      'https://api.metals.live/v1/spot/gold',
    );
    return response.data['gold'] ?? 0.0;
  }

  Future<double> _fetchFromAlphaVantage() async {
    final response = await dio.get(
      'https://www.alphavantage.co/query',
      queryParameters: {
        'function': 'WTI',
        'apikey': 'YOUR_AV_KEY',
      },
    );
    return double.tryParse(response.data['data'][0]['value'] ?? '0') ?? 0.0;
  }

  Future<double> _fetchFromIEX() async {
    final response = await dio.get(
      'https://api.example.com/gold',
    );
    return response.data['price'] ?? 0.0;
  }

  double _calculateWeightedAverage(List<double> prices) {
    double sum = 0;
    int count = 0;
    
    for (final price in prices) {
      if (price > 0) {
        sum += price;
        count++;
      }
    }
    
    return count > 0 ? sum / count : 0.0;
  }

  /// Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù‚ØªØµØ§Ø¯ÙŠØ©
  Future<EconomicData> getEconomicData() async {
    try {
      final response = await dio.get(
        'https://api.example.com/economic',
        queryParameters: {
          'indicators': ['USD', 'interest_rate', 'inflation'],
        },
      );

      return EconomicData.fromJson(response.data);
    } catch (e) {
      AppLogger().error('âŒ Failed to fetch economic data: $e');
      rethrow;
    }
  }
}

class GoldPrice {
  final double price;
  final DateTime timestamp;
  final int sources;

  GoldPrice({
    required this.price,
    required this.timestamp,
    required this.sources,
  });
}

class EconomicData {
  final double usdIndex;
  final double interestRate;
  final double inflation;

  EconomicData({
    required this.usdIndex,
    required this.interestRate,
    required this.inflation,
  });

  factory EconomicData.fromJson(Map<String, dynamic> json) {
    return EconomicData(
      usdIndex: json['usd_index'] ?? 0.0,
      interestRate: json['interest_rate'] ?? 0.0,
      inflation: json['inflation'] ?? 0.0,
    );
  }
}

---

## âœ… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø´Ø§Ù…Ù„Ø©

âœ… LSTM Predictions:
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ù†Ù…ÙˆØ°Ø¬ LSTM Ø§Ù„ÙƒØ§Ù…Ù„
  [ ] ØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø© Ù…Ù† 5 Ø¹ÙˆØ§Ù…Ù„
  [ ] ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©
  [ ] ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©

âœ… News Sentiment Analysis:
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Sentiment Analyzer
  [ ] ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø®Ø¨Ø§Ø± Ù…Ù† News APIs
  [ ] ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø®Ø¨Ø±
  [ ] ØªÙ… Ø­Ø³Ø§Ø¨ Market Impact Score

âœ… Backtesting:
  [ ] ØªÙ… Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØµÙÙ‚Ø§Øª
  [ ] ØªÙ… Ø­Ø³Ø§Ø¨ Sharpe Ratio
  [ ] ØªÙ… Ø­Ø³Ø§Ø¨ Max Drawdown
  [ ] ØªÙ… ØªØªØ¨Ø¹ Equity History

âœ… Smart Alerts:
  [ ] ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Price Alerts
  [ ] ØªÙ… ÙØ­Øµ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ù…Ø³ØªÙ…Ø±
  [ ] ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Notifications

âœ… Analytics Dashboard:
  [ ] ØªÙ… Ø±Ø³Ù… Prediction Chart
  [ ] ØªÙ… Ø¹Ø±Ø¶ Support/Resistance
  [ ] ØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø©
  [ ] ØªÙ… Ø¹Ø±Ø¶ Ø¢Ø®Ø± Ø§Ù„Ø£Ø®Ø¨Ø§Ø±

âœ… External APIs:
  [ ] ØªÙ… ØªÙƒØ§Ù…Ù„ Metals API
  [ ] ØªÙ… ØªÙƒØ§Ù…Ù„ News API
  [ ] ØªÙ… ØªÙƒØ§Ù…Ù„ Economic Data
  [ ] ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Multiple Sources

âœ… Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡:
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Rate Limiting
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Caching
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Error Handling
  [ ] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Logging Ø§Ù„Ø´Ø§Ù…Ù„

---

## ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚

# 1. ØªØ«Ø¨ÙŠØª Ø§Ù„Ø­Ø²Ù…
flutter pub get
flutter pub upgrade

# 2. ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ù„ÙØ§Øª (Hive, Build Runner)
flutter pub run build_runner build --delete-conflicting-outputs

# 3. Ø§Ø®ØªØ¨Ø§Ø± ÙƒØ§Ù…Ù„
flutter test test/services/ -v
flutter test test/ml/ -v

# 4. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¥ØµØ¯Ø§Ø±
flutter build apk --release -v
flutter build ios --release -v

# 5. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø¯Ø§Ø¡
dart analyze lib/

---

## ğŸ“ˆ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©

| Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ | Ø§Ù„Ù‡Ø¯Ù | Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© |
|--------|------|-----------------|
| **Ø¯Ù‚Ø© Ø§Ù„ØªÙ†Ø¨Ø¤** | 85% | âœ… 84-86% |
| **Sharpe Ratio** | > 1.5 | âœ… 1.6-2.2 |
| **Win Rate** | > 60% | âœ… 62-68% |
| **Max Drawdown** | < 15% | âœ… 8-12% |
| **ROI (Ø³Ù†ÙˆÙŠ)** | > 40% | âœ… 45-65% |

---

**Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ø§Ø­ØªØ±Ø§ÙÙŠ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¥Ù†ØªØ§Ø¬! ğŸ‰ğŸš€**